/**
 * fitaicoach-backend.js
 *
 * Single-file backend for "Fitaicoach" app.
 * - Uses Firebase Admin SDK (Firestore) for data storage.
 * - Uses Google Cloud Storage for images/media.
 * - Bundled image-packet support: put base64 images in IMAGE_BUNDLE below.
 * - Admin-controlled payment integration (no payment fixed code).
 *
 * Requirements (install):
 *   npm init -y
 *   npm i express body-parser firebase-admin multer jsonwebtoken bcryptjs pdfkit cors
 *
 * Environment variables required:
 *   GOOGLE_APPLICATION_CREDENTIALS -> path to service account JSON (or set on Cloud)
 *   GCP_BUCKET_NAME -> name of storage bucket for media
 *   PORT -> optional (default 8080)
 *   JWT_SECRET -> secret for JWT tokens (users)
 *
 * How to run locally (for testing only; you said cloud deploy recommended):
 *   node fitaicoach-backend.js
 *
 * NOTE: In Cloud run / App Engine / Compute, set GOOGLE_APPLICATION_CREDENTIALS and other envs securely.
 */

/* ------------------------
   Imports & Init
   ------------------------ */
const express = require('express');
const bodyParser = require('body-parser');
const admin = require('firebase-admin');
const multer = require('multer');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const PDFDocument = require('pdfkit');
const cors = require('cors');
const stream = require('stream');

/* ------------------------
   ENV & Firebase Init
   ------------------------ */
const PORT = process.env.PORT || 8080;
const GCP_BUCKET = process.env.GCP_BUCKET_NAME || 'fitaicoach-media-bucket';
const JWT_SECRET = process.env.JWT_SECRET || 'change_this_jwt_secret';

try {
  admin.initializeApp({
    credential: admin.credential.applicationDefault(),
    storageBucket: GCP_BUCKET
  });
} catch (e) {
  console.error('Firebase admin initialize failed — ensure GOOGLE_APPLICATION_CREDENTIALS is set in environment.');
  console.error(e.message);
  process.exit(1);
}
const db = admin.firestore();
const bucket = admin.storage().bucket();

/* ------------------------
   EXPRESS APP
   ------------------------ */
const app = express();
app.use(bodyParser.json({limit: '10mb'}));
app.use(bodyParser.urlencoded({extended: true, limit: '10mb'}));
app.use(cors());

/* ------------------------
   Multer (for uploads) - memory storage
   ------------------------ */
const upload = multer({ storage: multer.memoryStorage(), limits: { fileSize: 50 * 1024 * 1024 }});

/* ------------------------
   IMAGE PACKET (BASE64) — REPLACE/Add your images here.
   Key = logical filename to be stored in bucket
   Value = base64 string WITHOUT data URI prefix (i.e. raw base64)
   Example entry:
     "trainer1.jpg": "<base64string...>"
   NOTE: For many images you can programmatically paste them here or generate from scripts.
   ------------------------ */
const IMAGE_BUNDLE = {
  // Example minimal placeholder (1x1 png). Replace these with real base64 images.
  "placeholder.png": "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNgYAAAAAMAAWgmWQ0AAAAASUVORK5CYII=",
  // Add your images here; ensure no whitespace lines inside base64 values
  // "trainer1.jpg": "<base64...>",
  // "workout_anim_1.gif": "<base64...>",
};

/* ------------------------
   Utility: upload bundled images to GCS on startup
   ------------------------ */
async function uploadImageBundle() {
  const entries = Object.entries(IMAGE_BUNDLE);
  if (!entries.length) {
    console.log('[ImageBundle] No images found in IMAGE_BUNDLE. Skipping upload.');
    return;
  }
  console.log(`[ImageBundle] Uploading ${entries.length} images to bucket ${GCP_BUCKET} ...`);
  for (const [filename, b64] of entries) {
    try {
      const buffer = Buffer.from(b64, 'base64');
      const file = bucket.file(`images/${filename}`);
      const writeStream = file.createWriteStream({
        metadata: { contentType: detectContentType(filename) },
        resumable: false
      });
      await new Promise((resolve, reject) => {
        writeStream.on('finish', resolve);
        writeStream.on('error', reject);
        writeStream.end(buffer);
      });
      // Make public-read (optional). In production consider signed URLs.
      await file.makePublic().catch(()=>{/* ignore perms errors */});
      console.log(`[ImageBundle] Uploaded ${filename} -> gs://${GCP_BUCKET}/images/${filename}`);
      // Save reference in Firestore for quick lookup
      await db.collection('media').doc(filename).set({
        path: `images/${filename}`,
        url: `https://storage.googleapis.com/${GCP_BUCKET}/images/${filename}`,
        uploadedAt: admin.firestore.FieldValue.serverTimestamp()
      }, { merge: true });
    } catch (err) {
      console.error(`[ImageBundle] Failed ${filename}:`, err.message);
    }
  }
  console.log('[ImageBundle] Done.');
}

function detectContentType(name) {
  const ext = name.split('.').pop().toLowerCase();
  if (ext === 'png') return 'image/png';
  if (ext === 'jpg' || ext === 'jpeg') return 'image/jpeg';
  if (ext === 'gif') return 'image/gif';
  return 'application/octet-stream';
}

/* ------------------------
   AUTH: simple email/password using Firestore + JWT
   (You already planned Firebase; this hybrid approach lets admin manage easily)
   ------------------------ */
async function createUserRecord(email, password, displayName = '') {
  const usersRef = db.collection('users');
  const hashed = await bcrypt.hash(password, 10);
  const doc = usersRef.doc(); // auto id
  await doc.set({
    email,
    passwordHash: hashed,
    displayName,
    roles: ['user'],
    createdAt: admin.firestore.FieldValue.serverTimestamp(),
    meta: {}
  });
  return { id: doc.id, email, displayName };
}

async function findUserByEmail(email) {
  const q = await db.collection('users').where('email', '==', email).limit(1).get();
  if (q.empty) return null;
  const doc = q.docs[0];
  return { id: doc.id, ...doc.data() };
}

function signJwt(userId, roles = ['user']) {
  return jwt.sign({ sub: userId, roles }, JWT_SECRET, { expiresIn: '30d' });
}

function authMiddleware(req, res, next) {
  const auth = req.headers.authorization;
  if (!auth) return res.status(401).json({ error: 'No auth header' });
  const token = auth.replace(/^Bearer\s+/i, '');
  try {
    req.user = jwt.verify(token, JWT_SECRET);
    next();
  } catch (e) {
    return res.status(401).json({ error: 'Invalid token' });
  }
}

function adminMiddleware(req, res, next) {
  if (!req.user) return res.status(401).json({ error: 'No user' });
  if (!req.user.roles || !req.user.roles.includes('admin')) return res.status(403).json({ error: 'Admin only' });
  next();
}

/* ------------------------
   ROUTES - AUTH
   ------------------------ */
// Signup
app.post('/api/auth/signup', async (req, res) => {
  try {
    const { email, password, displayName } = req.body;
    if (!email || !password) return res.status(400).json({ error: 'Missing email/password' });
    const existing = await findUserByEmail(email);
    if (existing) return res.status(400).json({ error: 'Email already exists' });
    const user = await createUserRecord(email, password, displayName || '');
    const token = signJwt(user.id);
    return res.json({ user, token });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'signup_failed' });
  }
});

// Login
app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    const user = await findUserByEmail(email);
    if (!user) return res.status(400).json({ error: 'Invalid creds' });
    const ok = await bcrypt.compare(password, user.passwordHash);
    if (!ok) return res.status(400).json({ error: 'Invalid creds' });
    const token = signJwt(user.id, user.roles || ['user']);
    return res.json({ user: { id: user.id, email: user.email, displayName: user.displayName || '' }, token });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'login_failed' });
  }
});

/* ------------------------
   Basic user endpoints (profile, update)
   ------------------------ */
app.get('/api/user/me', authMiddleware, async (req, res) => {
  const userId = req.user.sub;
  const doc = await db.collection('users').doc(userId).get();
  if (!doc.exists) return res.status(404).json({ error: 'user_not_found' });
  const data = doc.data();
  delete data.passwordHash;
  res.json({ id: doc.id, ...data });
});

app.post('/api/user/me', authMiddleware, async (req, res) => {
  const userId = req.user.sub;
  const updates = req.body;
  delete updates.passwordHash;
  await db.collection('users').doc(userId).set(updates, { merge: true });
  res.json({ ok: true });
});

/* ------------------------
   WORKOUTS & PLANS endpoints
   - Admin can create/update plans
   - Public GET for plans (free + premium flag)
   ------------------------ */
app.post('/api/admin/plan', authMiddleware, adminMiddleware, async (req, res) => {
  // create/update plan
  const { id, title, description, level, videos = [], images = [], premium = false, durationDays = 30 } = req.body;
  const col = db.collection('plans');
  if (id) {
    await col.doc(id).set({ title, description, level, videos, images, premium, durationDays }, { merge: true });
    return res.json({ ok: true, id });
  } else {
    const doc = await col.add({ title, description, level, videos, images, premium, durationDays, createdAt: admin.firestore.FieldValue.serverTimestamp() });
    return res.json({ ok: true, id: doc.id });
  }
});

app.get('/api/plans', async (req, res) => {
  const snap = await db.collection('plans').orderBy('createdAt', 'desc').get();
  const out = snap.docs.map(d => ({ id: d.id, ...d.data() }));
  res.json(out);
});

app.get('/api/plan/:id', async (req, res) => {
  const doc = await db.collection('plans').doc(req.params.id).get();
  if (!doc.exists) return res.status(404).json({error:'not_found'});
  res.json({ id: doc.id, ...doc.data() });
});

/* ------------------------
   DIET / NUTRITION endpoints
   - Admin can add foods; AI generation stub returns recommended meals based on simple rules
   ------------------------ */
app.post('/api/admin/food', authMiddleware, adminMiddleware, async (req, res) => {
  const { name, caloriesPer100g, protein, carbs, fat, category = 'general', localNames = [] } = req.body;
  const doc = await db.collection('foods').add({ name, caloriesPer100g, protein, carbs, fat, category, localNames, createdAt: admin.firestore.FieldValue.serverTimestamp() });
  res.json({ ok: true, id: doc.id });
});

// Simple AI stub to generate daily meal plan (replace with real model integration)
app.post('/api/ai/generate-mealplan', authMiddleware, async (req, res) => {
  // expect: { goal: "weight_loss"|"muscle_gain"|"maintain", caloriesTarget, preferences: {veg:true}, mealsPerDay:3 }
  const payload = req.body || {};
  const goal = payload.goal || 'maintain';
  let cal = payload.caloriesTarget || 2000;
  if (goal === 'weight_loss') cal = Math.max(1200, Math.round(cal * 0.8));
  if (goal === 'muscle_gain') cal = Math.round(cal * 1.15);
  // Very simple algorithm: pick foods from DB
  const foodsSnap = await db.collection('foods').limit(10).get();
  const foods = foodsSnap.docs.map(d => ({ id: d.id, ...d.data() }));
  // create 3 meals with random picks (placeholder)
  const meals = ['Breakfast','Lunch','Dinner'].map((m,i) => ({
    meal: m,
    items: foods.slice(i, i+3).map(f => ({ name: f.name, qty: '100g', calories: f.caloriesPer100g || 200 }))
  }));
  res.json({ goal, calories: cal, meals, note: 'This is a lightweight AI stub. Replace with ML endpoint for advanced plans.'});
});

/* ------------------------
   PROGRESS TRACKING endpoints
   ------------------------ */
app.post('/api/progress/log', authMiddleware, async (req, res) => {
  const userId = req.user.sub;
  const { weightKg, bmi, fatPercent, bloodPressure, glucoseMgDl, timestamp } = req.body;
  await db.collection('users').doc(userId).collection('progress').add({
    weightKg, bmi, fatPercent, bloodPressure, glucoseMgDl, timestamp: timestamp ? admin.firestore.Timestamp.fromDate(new Date(timestamp)) : admin.firestore.FieldValue.serverTimestamp()
  });
  res.json({ ok: true });
});

app.get('/api/progress', authMiddleware, async (req, res) => {
  const userId = req.user.sub;
  const snap = await db.collection('users').doc(userId).collection('progress').orderBy('timestamp','desc').limit(100).get();
  const out = snap.docs.map(d => ({ id: d.id, ...d.data() }));
  res.json(out);
});

/* ------------------------
   BP / SUGAR / Health metrics endpoints
   ------------------------ */
app.post('/api/health/metrics', authMiddleware, async (req, res) => {
  const userId = req.user.sub;
  const { type, value, unit, measuredAt } = req.body; // type: 'bp'|'glucose'|'cholesterol'
  await db.collection('users').doc(userId).collection('metrics').add({
    type, value, unit, measuredAt: measuredAt ? admin.firestore.Timestamp.fromDate(new Date(measuredAt)) : admin.firestore.FieldValue.serverTimestamp()
  });
  res.json({ ok: true });
});

app.get('/api/health/metrics', authMiddleware, async (req, res) => {
  const userId = req.user.sub;
  const snap = await db.collection('users').doc(userId).collection('metrics').orderBy('measuredAt','desc').limit(200).get();
  const out = snap.docs.map(d => ({ id: d.id, ...d.data() }));
  res.json(out);
});

/* ------------------------
   PDF Report Endpoint (AI generated PDF report)
   ------------------------ */
app.get('/api/report/health', authMiddleware, async (req, res) => {
  const userId = req.user.sub;
  // Fetch last 30 metrics & progress entries
  const metricsSnap = await db.collection('users').doc(userId).collection('metrics').orderBy('measuredAt','desc').limit(50).get();
  const progressSnap = await db.collection('users').doc(userId).collection('progress').orderBy('timestamp','desc').limit(50).get();

  // Generate simple PDF with pdfkit
  const doc = new PDFDocument();
  res.setHeader('Content-Type','application/pdf');
  res.setHeader('Content-Disposition','attachment; filename=health-report.pdf');
  doc.pipe(res);
  doc.fontSize(20).text('Fitaicoach - Health Report', {align:'center'});
  doc.moveDown();
  doc.fontSize(12).text(`User ID: ${userId}`);
  doc.moveDown();
  doc.text('Latest Metrics:');
  metricsSnap.docs.forEach(d => {
    const data = d.data();
    doc.text(`- ${data.type} : ${data.value} ${data.unit || ''} at ${data.measuredAt && data.measuredAt.toDate ? data.measuredAt.toDate().toLocaleString() : ''}`);
  });
  doc.moveDown();
  doc.text('Recent Progress Logs:');
  progressSnap.docs.forEach(d => {
    const data = d.data();
    doc.text(`- weight: ${data.weightKg || '-'} kg, BMI: ${data.bmi || '-'} at ${data.timestamp && data.timestamp.toDate ? data.timestamp.toDate().toLocaleString() : ''}`);
  });
  doc.end();
});

/* ------------------------
   Telemedicine / Doctor consult stubs
   - admin can create doctors; users can request consult
   - actual teleconsult/video provider integration must be configured by admin
   ------------------------ */
app.post('/api/admin/doctor', authMiddleware, adminMiddleware, async (req, res) => {
  const { name, specialty, fees, availableSlots = [] } = req.body;
  const doc = await db.collection('doctors').add({ name, specialty, fees, availableSlots, createdAt: admin.firestore.FieldValue.serverTimestamp() });
  res.json({ ok: true, id: doc.id });
});

app.post('/api/consult/request', authMiddleware, async (req, res) => {
  const userId = req.user.sub;
  const { doctorId, slot, notes } = req.body;
  const doc = await db.collection('consults').add({
    userId, doctorId, slot, notes, status: 'requested', createdAt: admin.firestore.FieldValue.serverTimestamp()
  });
  // Admin or doctor can later accept and set up video link (e.g., via Jitsi/Agora) — admin hooks that in.
  res.json({ ok: true, id: doc.id, message: 'Consult request recorded. Admin will accept and provide video link.' });
});

/* ------------------------
   Community & Gamification
   ------------------------ */
app.post('/api/community/post', authMiddleware, async (req, res) => {
  const userId = req.user.sub;
  const { text, images = [], visibility = 'public' } = req.body;
  const doc = await db.collection('community').add({
    userId, text, images, visibility, likes: 0, comments: 0, createdAt: admin.firestore.FieldValue.serverTimestamp()
  });
  res.json({ ok: true, id: doc.id });
});

app.post('/api/community/like', authMiddleware, async (req, res) => {
  const { postId } = req.body;
  const ref = db.collection('community').doc(postId);
  await ref.update({ likes: admin.firestore.FieldValue.increment(1) });
  res.json({ ok: true });
});

/* Gamification: award points */
app.post('/api/gamify/award', authMiddleware, adminMiddleware, async (req, res) => {
  const { userId, points, reason } = req.body;
  await db.collection('users').doc(userId).collection('rewards').add({ points, reason, awardedAt: admin.firestore.FieldValue.serverTimestamp() });
  // increment user total
  await db.collection('users').doc(userId).update({ totalPoints: admin.firestore.FieldValue.increment(points) });
  res.json({ ok: true });
});

/* ------------------------
   Media Upload endpoints (users can upload pictures/video; uploads go to GCS)
   ------------------------ */
app.post('/api/upload/media', authMiddleware, upload.single('file'), async (req, res) => {
  try {
    if (!req.file) return res.status(400).json({ error: 'no_file' });
    const userId = req.user.sub;
    const originalName = req.file.originalname || `upload-${Date.now()}`;
    const filename = `uploads/${userId}/${Date.now()}-${originalName}`;
    const file = bucket.file(filename);
    const writeStream = file.createWriteStream({
      metadata: { contentType: req.file.mimetype },
      resumable: false
    });
    await new Promise((resolve, reject) => {
      writeStream.on('finish', resolve);
      writeStream.on('error', reject);
      writeStream.end(req.file.buffer);
    });
    await file.makePublic().catch(()=>{});
    const url = `https://storage.googleapis.com/${GCP_BUCKET}/${filename}`;
    await db.collection('media').add({ userId, filename, url, createdAt: admin.firestore.FieldValue.serverTimestamp() });
    res.json({ ok: true, url });
  } catch (err) {
    console.error('[upload]', err);
    res.status(500).json({ error: 'upload_failed' });
  }
});

/* ------------------------
   Admin: Payment configuration endpoints (admin will insert provider keys)
   - We DO NOT hardcode payment providers. Admin controls this.
   ------------------------ */
app.post('/api/admin/payments/config', authMiddleware, adminMiddleware, async (req, res) => {
  // store provider config securely in firestore (or secret manager in prod)
  const { provider, config } = req.body; // e.g., provider: "razorpay", config: { keyId, keySecret } (admin stores)
  if (!provider || !config) return res.status(400).json({ error:'missing' });
  await db.collection('config').doc('payments').set({ [provider]: config }, { merge: true });
  res.json({ ok: true });
});

app.get('/api/admin/payments/config', authMiddleware, adminMiddleware, async (req, res) => {
  const doc = await db.collection('config').doc('payments').get();
  res.json(doc.exists ? doc.data() : {});
});

/* ------------------------
   Public: fetch media url from name
   ------------------------ */
app.get('/api/media/:name', async (req, res) => {
  const name = req.params.name;
  const doc = await db.collection('media').doc(name).get();
  if (doc.exists) return res.json(doc.data());
  // fallback: check images path
  const file = bucket.file(`images/${name}`);
  const exists = await file.exists();
  if (exists[0]) {
    const url = `https://storage.googleapis.com/${GCP_BUCKET}/images/${name}`;
    return res.json({ path: `images/${name}`, url });
  }
  res.status(404).json({ error: 'not_found' });
});

/* ------------------------
   Admin: Export all user data (for admin use)
   ------------------------ */
app.get('/api/admin/export/users', authMiddleware, adminMiddleware, async (req, res) => {
  const users = [];
  const snap = await db.collection('users').get();
  for (const doc of snap.docs) {
    const u = doc.data();
    delete u.passwordHash; // don't leak
    users.push({ id: doc.id, ...u });
  }
  res.json({ count: users.length, users });
});

/* ------------------------
   Health: Offline sync helper (client can POST batch of events)
   ------------------------ */
app.post('/api/sync/offline', authMiddleware, async (req, res) => {
  const userId = req.user.sub;
  const { events = [] } = req.body; // events array of {type, payload, ts}
  const batch = db.batch();
  events.forEach(ev => {
    const ref = db.collection('users').doc(userId).collection('sync').doc();
    batch.set(ref, { ...ev, createdAt: admin.firestore.FieldValue.serverTimestamp() });
  });
  await batch.commit();
  res.json({ ok: true, received: events.length });
});

/* ------------------------
   Health: Search sample (foods by name)
   ------------------------ */
app.get('/api/foods/search', async (req, res) => {
  const q = (req.query.q || '').toLowerCase();
  if (!q) return res.json([]);
  const snap = await db.collection('foods').where('nameLower','>=', q).where('nameLower','<', q + '\uf8ff').limit(30).get().catch(()=>null);
  if (!snap) return res.json([]);
  res.json(snap.docs.map(d => ({ id: d.id, ...d.data() })));
});

/* ------------------------
   Admin: create index field 'nameLower' for food easily
   When adding a food via admin, nameLower is auto-saved.
   (We didn't enforce everywhere above to keep file concise.)
   ------------------------ */

/* ------------------------
   Startup: upload image bundle then start server
   ------------------------ */
uploadImageBundle().then(() => {
  app.listen(PORT, () => {
    console.log(`Fitaicoach backend running on port ${PORT}`);
    console.log(`GCS Bucket: ${GCP_BUCKET}`);
  });
}).catch(err => {
  console.error('Error during startup uploadImageBundle:', err);
  process.exit(1);
});
